import express from 'express';
import cors from 'cors';
import pkg from 'pg';
import { randomUUID } from 'crypto';
import 'dotenv/config';

const { Pool } = pkg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

const app = express();
app.use(cors());
app.use(express.json({ limit: '2mb' }));

const API_PREFIX = '/api/v1';
const PAYMENT_METHODS = new Set(['transfer', 'check', 'credit_card', 'cash']);
const TRANSACTION_TYPES = new Set(['income', 'expense']);
const TRANSACTION_STATUSES = new Set(['pending', 'completed']);

const normalizeDateKey = (value) => {
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
      return trimmed;
    }
  }
  const now = new Date();
  return now.toISOString().slice(0, 10);
};

const sanitizeTransaction = (transaction, index) => {
  if (!transaction || typeof transaction !== 'object') {
    throw new Error(`Transaction at index ${index} is invalid`);
  }

  const id =
    typeof transaction.id === 'string' && transaction.id.trim()
      ? transaction.id.trim()
      : randomUUID();
  const date = normalizeDateKey(transaction.date);
  const amount = Number(transaction.amount);

  if (!Number.isFinite(amount)) {
    throw new Error(`Transaction ${id} has invalid amount`);
  }

  const type = TRANSACTION_TYPES.has(transaction.type) ? transaction.type : 'expense';
  const group = typeof transaction.group === 'string' ? transaction.group : 'operational';
  const category =
    typeof transaction.category === 'string' && transaction.category.trim()
      ? transaction.category.trim()
      : 'ללא קטגוריה';
  const description = typeof transaction.description === 'string' ? transaction.description : '';
  const paymentMethod = PAYMENT_METHODS.has(transaction.paymentMethod)
    ? transaction.paymentMethod
    : 'transfer';
  const status = TRANSACTION_STATUSES.has(transaction.status) ? transaction.status : 'pending';
  const clientReference =
    typeof transaction.clientReference === 'string' && transaction.clientReference.trim()
      ? transaction.clientReference.trim()
      : null;

  return {
    id,
    date,
    amount: Math.abs(Number(amount.toFixed(2))),
    type,
    group,
    category,
    description,
    paymentMethod,
    status,
    clientReference,
    isManualOverride: Boolean(transaction.isManualOverride),
    isRecurring: Boolean(transaction.isRecurring),
    loanEndMonth:
      typeof transaction.loanEndMonth === 'string' && transaction.loanEndMonth.trim()
        ? transaction.loanEndMonth.trim()
        : null,
    linkedMonth:
      typeof transaction.linkedMonth === 'string' && transaction.linkedMonth.trim()
        ? transaction.linkedMonth.trim()
        : null,
    isAutoGenerated: Boolean(transaction.isAutoGenerated),
  };
};

const sanitizeTransactionList = (list) => {
  if (!Array.isArray(list)) {
    throw new Error('transactions must be an array');
  }

  return list.map((item, index) => sanitizeTransaction(item, index));
};

const sanitizeStringArray = (values) => {
  if (!Array.isArray(values)) {
    return [];
  }
  const seen = new Set();
  const sanitized = [];

  values.forEach((entry) => {
    if (typeof entry !== 'string') {
      return;
    }
    const trimmed = entry.trim();
    if (!trimmed || seen.has(trimmed)) {
      return;
    }
    seen.add(trimmed);
    sanitized.push(trimmed);
  });

  return sanitized;
};

const sanitizeCustomCategories = (categories) => {
  if (!Array.isArray(categories)) {
    return [];
  }
  return categories.filter(
    (category) => category && typeof category === 'object' && typeof category.name === 'string'
  );
};

const sanitizeLoanOverrides = (overrides) => {
  if (!overrides || typeof overrides !== 'object') {
    return {};
  }
  const sanitized = {};
  Object.entries(overrides).forEach(([key, value]) => {
    if (typeof key !== 'string' || !key.trim()) {
      return;
    }
    const amount = Number(value);
    if (!Number.isFinite(amount)) {
      return;
    }
    sanitized[key.trim()] = Math.abs(Number(amount.toFixed(2)));
  });
  return sanitized;
};

const mapRowToTransaction = (row) => ({
  id: row.id,
  date: typeof row.date === 'string' ? row.date : row.date?.toISOString()?.slice(0, 10),
  amount: Number(row.amount),
  type: row.type,
  group: row.group,
  category: row.category,
  description: row.description || '',
  status: row.status || 'pending',
  paymentMethod: row.payment_method || 'transfer',
  clientReference: row.client_reference || undefined,
  isManualOverride: row.is_manual_override || false,
  isRecurring: row.is_recurring || false,
  loanEndMonth: row.loan_end_month || undefined,
  linkedMonth: row.linked_month || undefined,
  isAutoGenerated: row.is_auto_generated || false,
});

const fetchTransactions = async (userId) => {
  const { rows } = await pool.query(
    'SELECT * FROM transactions WHERE user_id = $1 ORDER BY date, created_at',
    [userId]
  );
  return rows.map(mapRowToTransaction);
};

const readSetting = async (userId, key, fallback) => {
  const { rows } = await pool.query(
    'SELECT value FROM settings WHERE user_id = $1 AND key = $2 LIMIT 1',
    [userId, key]
  );

  if (!rows.length) {
    return fallback;
  }

  return rows[0].value ?? fallback;
};

const upsertSetting = (client, userId, key, value) =>
  client.query(
    `
      INSERT INTO settings (user_id, key, value)
      VALUES ($1, $2, $3::jsonb)
      ON CONFLICT (user_id, key)
      DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()
    `,
    [userId, key, JSON.stringify(value)]
  );

const replaceTransactions = async (client, userId, transactions) => {
  await client.query('DELETE FROM transactions WHERE user_id = $1', [userId]);
  for (const tx of transactions) {
    await client.query(
      `INSERT INTO transactions (
        id,
        user_id,
        date,
        amount,
        type,
        "group",
        category,
        description,
        status,
        payment_method,
        client_reference,
        is_manual_override,
        is_recurring,
        loan_end_month,
        linked_month,
        is_auto_generated
      ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16)`,
      [
        tx.id,
        userId,
        tx.date,
        tx.amount,
        tx.type,
        tx.group,
        tx.category,
        tx.description,
        tx.status,
        tx.paymentMethod,
        tx.clientReference,
        tx.isManualOverride,
        tx.isRecurring,
        tx.loanEndMonth,
        tx.linkedMonth,
        tx.isAutoGenerated,
      ]
    );
  }
};

const authenticate = async (req, res, next) => {
  try {
    const header = req.get('authorization');
    if (!header || !header.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Missing Authorization header' });
    }

    const token = header.slice(7).trim();
    if (!token) {
      return res.status(401).json({ error: 'Invalid token' });
    }

    const { rows } = await pool.query(
      'SELECT id, username, role FROM users WHERE api_token = $1 LIMIT 1',
      [token]
    );

    if (!rows.length) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    req.user = rows[0];
    next();
  } catch (error) {
    console.error('Auth error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
};

// Root route
app.get('/', (req, res) => {
  res.json({
    message: 'LegalFlow API is running',
    version: '1.0.0',
    description: 'Legal practice management system',
    endpoints: {
      health: '/health',
      login: `${API_PREFIX}/auth/login`,
      state: `${API_PREFIX}/state`,
    },
  });
});

// Health check
app.get('/health', (req, res) => res.json({ ok: true }));

app.post(`${API_PREFIX}/auth/login`, async (req, res) => {
  const { username, password } = req.body || {};

  if (!username || !password) {
    return res.status(400).json({ error: 'חובה להזין שם משתמש וסיסמה' });
  }

  try {
    const { rows } = await pool.query(
      'SELECT id, username, password_hash, role FROM users WHERE lower(username) = lower($1) LIMIT 1',
      [username]
    );

    if (!rows.length) {
      return res.status(401).json({ error: 'שם משתמש או סיסמה שגויים' });
    }

    const user = rows[0];
    if (user.password_hash !== password) {
      return res.status(401).json({ error: 'שם משתמש או סיסמה שגויים' });
    }

    const token = randomUUID();
    await pool.query('UPDATE users SET api_token = $1 WHERE id = $2', [token, user.id]);

    res.json({
      token,
      user: {
        username: user.username,
        role: user.role,
      },
    });
  } catch (error) {
    console.error('Login failed:', error);
    res.status(500).json({ error: 'שגיאה בשרת, נסה שוב בעוד מספר דקות' });
  }
});

app.get(`${API_PREFIX}/state`, authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const [transactions, initialBalance, clients, customCategories, loanOverrides] =
      await Promise.all([
        fetchTransactions(userId),
        readSetting(userId, 'initialBalance', 0),
        readSetting(userId, 'clients', []),
        readSetting(userId, 'customCategories', []),
        readSetting(userId, 'loanOverrides', {}),
      ]);

    res.json({
      transactions,
      initialBalance,
      clients,
      customCategories,
      loanOverrides,
      updatedAt: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Failed to fetch state:', error);
    res.status(500).json({ error: 'Failed to fetch state' });
  }
});

app.post(`${API_PREFIX}/state`, authenticate, async (req, res) => {
  const { transactions, initialBalance, clients, customCategories, loanOverrides } = req.body || {};

  try {
    const sanitizedTransactions = sanitizeTransactionList(transactions || []);
    const normalizedInitialBalance =
      typeof initialBalance === 'number' && Number.isFinite(initialBalance)
        ? Number(initialBalance.toFixed(2))
        : 0;
    const sanitizedClients = sanitizeStringArray(clients);
    const sanitizedCustomCategories = sanitizeCustomCategories(customCategories);
    const sanitizedLoanOverrides = sanitizeLoanOverrides(loanOverrides);

    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      await replaceTransactions(client, req.user.id, sanitizedTransactions);
      await Promise.all([
        upsertSetting(client, req.user.id, 'initialBalance', normalizedInitialBalance),
        upsertSetting(client, req.user.id, 'clients', sanitizedClients),
        upsertSetting(client, req.user.id, 'customCategories', sanitizedCustomCategories),
        upsertSetting(client, req.user.id, 'loanOverrides', sanitizedLoanOverrides),
      ]);
      await client.query('COMMIT');
      res.json({ ok: true, count: sanitizedTransactions.length });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Failed to persist state:', error);
      res.status(500).json({ error: 'Failed to persist state' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Invalid payload:', error);
    res.status(400).json({ error: error.message || 'Invalid payload' });
  }
});

app.use((err, req, res, _next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ error: 'Internal Server Error' });
});

const port = process.env.PORT || 4000;
app.listen(port, () => console.log(`API listening on ${port}`));